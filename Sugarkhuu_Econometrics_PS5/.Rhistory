m_melt
colNames(m_melt)
m_melt
ggplot(data = m_melt, aes(x=Var1, y=Var2, fill=value))
ggplot(data = m_melt, aes(x=Var1, y=Var2, fill=value)) +
geom_tile()
ggplot(data = m_melt, aes(x=Var1, y=Var2, fill=valueshki)) +
geom_tile()
ggplot(data = m_melt, aes(x=Var1, y=Var2, fill=valueshki)) +
geom_tile()
m_melt
m <- summ_result[,,7]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=Var1, y=Var2, fill=value)) +
geom_tile()
summ_result[1,1,]
rownames(summ_result[1,1,]) <- '15'
rownames(summ_result[1,1,:]) <- '15'
summ_result[1,1,:] <-as.matrix(c(mean_mat[1:3],var_mat[1:3],mean_mat[4]),dimnames=list("ha",1:7)
summ_result[1,1,] <-as.matrix(c(mean_mat[1:3],var_mat[1:3],mean_mat[4]),dimnames=list("ha",1:7)
)
summ_result[1,1,]
rownames(summ_result[1,1,])
m_melt
m <- summ_result[,,7]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=20:39, y=Var2, fill=value)) +
geom_tile()
m_melt
dim(m_melt)
m <- summ_result[,,7]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=1:400, y=Var2, fill=value)) +
geom_tile()
m <- summ_result[,,6]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=1:400, y=Var2, fill=value)) +
geom_tile()
m_melt
rhos
rep(rhos,20)
m <- summ_result[,,6]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=rep(rhos,20), y=Var2, fill=value)) +
geom_tile()
m <- summ_result[,,6]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=rep(rhos,20), y=rep(ns,20), fill=value)) +
geom_tile()
rep(ns,20)
m <- summ_result[,,6]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=rep(rhos,20), y=Var2, fill=value)) +
geom_tile()
m_melt
ns
rep(ns,20)
rep(ns,each=20)
m <- summ_result[,,6]
m_melt <- melt(m)
ggplot(data = m_melt, aes(x=rep(rhos,20), y=rep(ns,each=20), fill=value)) +
geom_tile()
m_melt
m_melt$rhos <- rep(rhos,20)
m_melt$nss <- rep(rhos,20)
m_melt$ns <- rep(rhos,20)
m_melt$rhos <- rep(rhos,20)
m_melt$ns <- rep(rhos,20)
m_melt$rhos <- rep(rhos,20)
m_melt$ns <- rep(ns,each = 20)
m <- summ_result[,,6]
m_melt <- melt(m)
m_melt$rhos <- rep(rhos,20)
m_melt$ns <- rep(ns,each = 20)
ggplot(data = m_melt, aes(x=rhos, y=ns, fill=value)) +
geom_tile()
m_melt
summ_result
m
head(m_melt)
m[1:4,1]
m
rownames(m)
rownames(m) <- rhos
rownames(m) <- ns
rownames(m) <- rhos
colnames(m) <- ns
m
m_melt <- melt(m)
m_melt
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"))
m_melt$rhos <- rep(rhos,20)
m_melt$ns <- rep(ns,each = 20)
ggplot(data = m_melt, aes(x=rho, y=n, fill=value)) +
geom_tile()
head(m_melt)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "climate_value")
ggplot(data = m_melt, aes(x=rho, y=n, fill=value)) +
geom_tile()
head(m_melt)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "E")
ggplot(data = m_melt, aes(x=rho, y=n, fill=E)) +
geom_tile()
head(m_melt)
TeX
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = expression(beta))
ggplot(data = m_melt, aes(x=rho, y=n, fill=expression(beta))) +
geom_tile()
head(m_melt)
expression(beta)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = mean)
ggplot(data = m_melt, aes(x=rho, y=n, fill=mean)) +
geom_tile()
head(m_melt)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = mean)
ggplot(data = m_melt, aes(x=rho, y=n, fill=mean)) +
geom_tile()
head(m_melt)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = avg)
ggplot(data = m_melt, aes(x=rho, y=n, fill=avg)) +
geom_tile()
head(m_melt)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "mean")
ggplot(data = m_melt, aes(x=rho, y=n, fill=mean)) +
geom_tile()
head(m_melt)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "Expected value")
ggplot(data = m_melt, aes(x=rho, y=n, fill="Expected value")) +
geom_tile()
head(m_melt)
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "Expected_value")
ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
head(m_melt)
p1 <- ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
p2 <- ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
grid.arrange(p1,p2,nrow=1)
library(gridExtra)
grid.arrange(p1,p2,nrow=1)
ggsave("mtcars.png")
m <- summ_result[,,6]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "Expected_value")
p1 <- ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
ggsave("mtcars.png")
m <- summ_result[,,1]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "Expected_value")
p1 <- ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
ggsave("mtcars.png")
m_melt <- melt(m,c("rho", "n"),value.name = "Expected_value")
p1 <- ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
m <- summ_result[,,1]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "Expected_value")
ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
ggsave("mtcars.png")
vars <- c("E_beta1","Var_beta1","E_R2")
"hi" + "ba"
["hi", "ba"]
paste(vars[i], ".png", sep="")
paste(vars[1], ".png", sep="")
vars <- c("E_beta1","Var_beta1","E_R2")
for(i in 1:length(vars)){
m <- summ_result[,,i]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "Expected_value")
ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
ggsave(paste(vars[i], ".png", sep=""))
}
head(m_melt)
# https://stats.stackexchange.com/questions/83172/generate-two-variables-with-precise-pre-specified-correlation
# library
library(tictoc)
library(ggplot2)
library(reshape2)
r_squared <- function(beta, X, Y){
# calculate R squared given beta, X and Y
Y_hat <- X%*%beta_est
EY_hat <- mean(Y_hat) # <- EY
EY <- mean(Y)
r2 <- sum((Y_hat-EY_hat)^2)/sum((Y-EY)^2)
return(r2)
}
my_estimator <- function(rho=0.7,n=1000) {
beta <- c(2,1,-1)
VCOV_mat <- data.frame(c(1, rho),c(rho,1)) # data.frame(c(10, 30),c(30,100))
MEAN_mat <- c(2,-3) # c(10,100)
A = as.matrix(VCOV_mat)
q = c(dim(A)[2])
r_chol <- chol(A)
r_mat <- matrix(rnorm(n*q), ncol=q)
X_0 <- r_mat %*% r_chol
X <-  X_0 + matrix(MEAN_mat, nrow=n, ncol=q, byrow=TRUE)
X <- cbind(X,intercept=1);
e <- runif(n,-2,2)
Y <- X %*% beta + e
beta_est <- solve((t(X) %*% X)) %*% (t(X) %*% Y)
r2 <- r_squared(beta_est, X, Y)
return(c(beta_est, r2))
}
tic()
rhos <- seq(0., 0.95, 0.05)
ns <- seq(500, 10000, 500)
times <- 500
summ_result <- array(0, dim = c(length(rhos), length(ns), 7))
for(rho_i in 1:length(rhos)){
rho <- rhos[rho_i]
for(n_i in 1:length(ns)){
n <- ns[n_i]
matrix_out <- array(0,dim=c(times,4))
for(i in 1:times){
print(c(rho, n))
matrix_out[i,] <- my_estimator(rho, n)
}
mean_mat <- colMeans(matrix_out)
var_mat <- diag(var(matrix_out))
summ_result[rho_i,n_i,] <- c(mean_mat[1],var_mat[1],mean_mat[4])
}
}
toc()
vars <- c("E_beta1","Var_beta1","E_R2")
for(i in 1:length(vars)){
m <- summ_result[,,i]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "Expected_value")
ggplot(data = m_melt, aes(x=rho, y=n, fill=Expected_value)) +
geom_tile()
ggsave(paste(vars[i], ".png", sep=""))
}
# https://stats.stackexchange.com/questions/83172/generate-two-variables-with-precise-pre-specified-correlation
# library
library(tictoc)
library(ggplot2)
library(reshape2)
r_squared <- function(beta, X, Y){
# calculate R squared given beta, X and Y
Y_hat <- X%*%beta_est
EY_hat <- mean(Y_hat) # <- EY
EY <- mean(Y)
r2 <- sum((Y_hat-EY_hat)^2)/sum((Y-EY)^2)
return(r2)
}
my_estimator <- function(rho=0.7,n=1000) {
beta <- c(2,1,-1)
VCOV_mat <- data.frame(c(1, rho),c(rho,1)) # data.frame(c(10, 30),c(30,100))
MEAN_mat <- c(2,-3) # c(10,100)
A = as.matrix(VCOV_mat)
q = c(dim(A)[2])
r_chol <- chol(A)
r_mat <- matrix(rnorm(n*q), ncol=q)
X_0 <- r_mat %*% r_chol
X <-  X_0 + matrix(MEAN_mat, nrow=n, ncol=q, byrow=TRUE)
X <- cbind(X,intercept=1);
e <- runif(n,-2,2)
Y <- X %*% beta + e
beta_est <- solve((t(X) %*% X)) %*% (t(X) %*% Y)
r2 <- r_squared(beta_est, X, Y)
return(c(beta_est, r2))
}
tic()
rhos <- seq(0., 0.95, 0.05)
ns <- seq(500, 10000, 500)
vars <- c("E_beta1","Var_beta1","E_R2")
times <- 500
summ_result <- array(0, dim = c(length(rhos), length(ns), length(vars)))
for(rho_i in 1:length(rhos)){
rho <- rhos[rho_i]
for(n_i in 1:length(ns)){
n <- ns[n_i]
matrix_out <- array(0,dim=c(times,4))
for(i in 1:times){
print(c(rho, n))
matrix_out[i,] <- my_estimator(rho, n)
}
mean_mat <- colMeans(matrix_out)
var_mat <- diag(var(matrix_out))
summ_result[rho_i,n_i,] <- c(mean_mat[1],var_mat[1],mean_mat[4])
}
}
toc()
## libraries
library(tictoc)
library(ggplot2)
library(reshape2)
matrix_out
# https://stats.stackexchange.com/questions/83172/generate-two-variables-with-precise-pre-specified-correlation
## libraries
library(tictoc)
library(ggplot2)
library(reshape2)
## functions
r_squared <- function(beta, X, Y){
# calculate R squared given beta, X and Y
Y_hat <- X%*%beta_est
EY_hat <- mean(Y_hat) # <=> EY
EY <- mean(Y)
r2 <- sum((Y_hat-EY_hat)^2)/sum((Y-EY)^2)
return(r2)
}
my_estimator <- function(rho=0.7,n=1000) {
# return estimated betas and r squared for a random sample
beta <- c(2,1,-1)
VCOV_mat <- data.frame(c(1, rho),c(rho,1)) # of Xs
MEAN_mat <- c(2,-3) # c(10,100)            # of Xs
A = as.matrix(VCOV_mat)                    # just rename
q = c(dim(A)[2])                           # number of X variables
r_chol <- chol(A)                          # Cholesky decomp. of A
r_mat <- matrix(rnorm(n*q), ncol=q)        # draws from standard normal dist. of size nxq
X_0 <- r_mat %*% r_chol                    # random sample with demeaned Xs
X <-  X_0 + matrix(MEAN_mat, nrow=n, ncol=q, byrow=TRUE) # add respective means to the demeaned Xs
X <- cbind(X,intercept=1);                 # add the intercept
e <- runif(n,-2,2)                         # random error draws
Y <- X %*% beta + e                        # draws of Y. Now, the observed values.
beta_est <- solve((t(X) %*% X)) %*% (t(X) %*% Y) # estimate the betas
r2 <- r_squared(beta_est, X, Y)            # r squared
return(c(beta_est, r2))
}
# Computation
rhos  <- seq(0., 0.95, 0.05)   # grid of rho
ns    <- seq(500, 10000, 500)  # grid of n
vars  <- c("E_beta1","Var_beta1","E_R2") # name of the variables
times <- 500
tic()
# save the results of each rho and n for each of the variables
summ_result <- array(0, dim = c(length(rhos), length(ns), length(vars)))
for(rho_i in 1:length(rhos)){
rho <- rhos[rho_i]
for(n_i in 1:length(ns)){
n <- ns[n_i]
matrix_out <- array(0,dim=c(times,4))
for(i in 1:times){
# print(c(rho, n))
matrix_out[i,] <- my_estimator(rho, n)  # beta1 - beta3, and R2
}
mean_mat <- colMeans(matrix_out) # mean over the 500 draws
var_mat <- diag(var(matrix_out)) # variance over the 500 draws
summ_result[rho_i,n_i,] <- c(mean_mat[1],var_mat[1],mean_mat[4]) # mean of beta1, variance of beta1, and mean of R2
}
}
toc()
# plot
for(i in 1:length(vars)){
m <- summ_result[,,i]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "result")
ggplot(data = m_melt, aes(x=rho, y=n, fill=result)) +
geom_tile()
ggsave(paste(vars[i], ".png", sep=""))
}
# https://stats.stackexchange.com/questions/83172/generate-two-variables-with-precise-pre-specified-correlation
## libraries
library(tictoc)
library(ggplot2)
library(reshape2)
## functions
r_squared <- function(beta, X, Y){
# calculate R squared given beta, X and Y
Y_hat <- X%*%beta_est
EY_hat <- mean(Y_hat) # <=> EY
EY <- mean(Y)
r2 <- sum((Y_hat-EY_hat)^2)/sum((Y-EY)^2)
return(r2)
}
my_estimator <- function(rho=0.7,n=1000) {
# return estimated betas and r squared for a random sample
beta <- c(2,1,-1)
VCOV_mat <- data.frame(c(1, rho),c(rho,1)) # of Xs
MEAN_mat <- c(2,-3) # c(10,100)            # of Xs
A = as.matrix(VCOV_mat)                    # just rename
q = c(dim(A)[2])                           # number of X variables
r_chol <- chol(A)                          # Cholesky decomp. of A
r_mat <- matrix(rnorm(n*q), ncol=q)        # draws from standard normal dist. of size nxq
X_0 <- r_mat %*% r_chol                    # random sample with demeaned Xs
X <-  X_0 + matrix(MEAN_mat, nrow=n, ncol=q, byrow=TRUE) # add respective means to the demeaned Xs
X <- cbind(X,intercept=1);                 # add the intercept
e <- runif(n,-2,2)                         # random error draws
Y <- X %*% beta + e                        # draws of Y. Now, the observed values.
beta_est <- solve((t(X) %*% X)) %*% (t(X) %*% Y) # estimate the betas
r2 <- r_squared(beta_est, X, Y)            # r squared
return(c(beta_est, r2))
}
# Computation
rhos  <- seq(0., 0.95, 0.05)   # grid of rho
ns    <- seq(500, 10000, 500)  # grid of n
vars  <- c("E_beta1","Var_beta1","E_R2") # name of the variables
times <- 500
tic()
# save the results of each rho and n for each of the variables
summ_result <- array(0, dim = c(length(rhos), length(ns), length(vars)))
for(rho_i in 1:length(rhos)){
rho <- rhos[rho_i]
for(n_i in 1:length(ns)){
n <- ns[n_i]
matrix_out <- array(0,dim=c(times,4))
for(i in 1:times){
print(c(rho, n))
matrix_out[i,] <- my_estimator(rho, n)  # beta1 - beta3, and R2
}
mean_mat <- colMeans(matrix_out) # mean over the 500 draws
var_mat <- diag(var(matrix_out)) # variance over the 500 draws
summ_result[rho_i,n_i,] <- c(mean_mat[1],var_mat[1],mean_mat[4]) # mean of beta1, variance of beta1, and mean of R2
}
}
toc()
# plot
for(i in 1:length(vars)){
m <- summ_result[,,i]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "result")
ggplot(data = m_melt, aes(x=rho, y=n, fill=result)) +
geom_tile()
ggsave(paste(vars[i], ".png", sep=""))
}
# https://stats.stackexchange.com/questions/83172/generate-two-variables-with-precise-pre-specified-correlation
## libraries
library(tictoc)
library(ggplot2)
library(reshape2)
# import
source("utils.R")
# Computation
rhos  <- seq(0., 0.95, 0.05)   # grid of rho
ns    <- seq(500, 10000, 500)  # grid of n
vars  <- c("E_beta1","Var_beta1","E_R2") # name of the variables
times <- 500
tic()
# save the results of each rho and n for each of the variables
summ_result <- array(0, dim = c(length(rhos), length(ns), length(vars)))
for(rho_i in 1:length(rhos)){
rho <- rhos[rho_i]
for(n_i in 1:length(ns)){
n <- ns[n_i]
matrix_out <- array(0,dim=c(times,4))
for(i in 1:times){
print(c(rho, n))
matrix_out[i,] <- my_estimator(rho, n)  # beta1 - beta3, and R2
}
mean_mat <- colMeans(matrix_out) # mean over the 500 draws
var_mat <- diag(var(matrix_out)) # variance over the 500 draws
summ_result[rho_i,n_i,] <- c(mean_mat[1],var_mat[1],mean_mat[4]) # mean of beta1, variance of beta1, and mean of R2
}
}
toc()
# plot
for(i in 1:length(vars)){
m <- summ_result[,,i]
rownames(m) <- rhos
colnames(m) <- ns
m_melt <- melt(m,c("rho", "n"),value.name = "result") # plotting grid
# heatmap
ggplot(data = m_melt, aes(x=rho, y=n, fill=result)) +
geom_tile()
ggsave(paste(vars[i], ".png", sep=""))
}
# Values of variance of beta1
var_beta1_rho000_n500   <- summ_result[1,1,2]
var_beta1_rho000_n10000 <- summ_result[1,20,2]
var_beta1_rho095_n500   <- summ_result[20,1,2]
var_beta1_rho095_n10000 <- summ_result[20,20,2]
setwd("D:/Documents/phd/bonn/phd21/econoPhD21/Sugarkhuu_Econometrics_PS5")
source("utils.R")
qt?
:
?qt
install.packages('vscDebugger')
